<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>My Private Leaking Investigation</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">
		<link rel="stylesheet" href="css/styles.css">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>My Private Leaking Investigation</h1>
					<small>„It's a mystery to me, the game commences“</small><br/><br/>
					<img src="images/detective.png" style="margin:0; background: none; border: none; box-shadow: none;" />
				</section>

				<section>
					<h2>Application Optimizations</h2>
					<div class="story">Get to know the police force</div>
					<ul>
						<li>Code Performance</li>
						<li>Memory optimization</li>
					</ul>
				</section>

				<section>
					<h2>Memory Optimizations</h2>
					<div class="story">Get to know your department</div>
					<ul>
						<li class="fragment" data-fragment-index="0">Memory management
							<ol>
								<li class="fragment" data-fragment-index="1">We may be using more memory than our App needs</li>
								<li class="fragment" data-fragment-index="2">GC may be allocating too frequently</li>
							</ol>
						</li>
						<li class="fragment" data-fragment-index="3">Memory leaks
							<ol>
								<li class="fragment" data-fragment-index="4">Massive JavaScript objects may be left with references</li>
								<li class="fragment" data-fragment-index="5">Detached DOM node trees may still have references by GC roots</li>
							</ol>
						</li>
					</ul>
				</section>

				<section>
					<section>
						<h2>Theory</h2>
						<div class="story">Short detective course</div>
					</section>

					<section>
						<h2>Objects sizes</h2>
						<div class="story">Study the mafia heirarchy</div>
						<div>
							<div style="float: left; width: 40%">
								<ul>
									<li class="fragment" data-fragment-index="0"><u>Shallow size</u> <br/>self obtained size</li>
									<li class="fragment" data-fragment-index="1"><u>Retained size</u> <br/>consists of self size and sizes of all nodes referenced by the object</li>
								</ul>
							</div>
							<div style="float: right;" class="fragment" data-fragment-index="0">
								<img src="images/objects-sizes.png"/>
							</div>
						</div>
					</section>

					<section>
						<h2>Objects retaining tree</h2>
						<div class="story">Bring down the boss and they will all fall</div>
						<div>
							<div style="float: left; width: 40%">
								<ul>
									<li class="fragment" data-fragment-index="0">Trees are made out of nodes (objects), interconnected by edges (objects properties)</li>
									<li class="fragment" data-fragment-index="1">DOM trees are native DOM elements reachable from the document root</li>
									<li class="fragment" data-fragment-index="2">Detached DOM trees are trees that have released all references to the document</li>
								</ul>
							</div>
							<div style="float: right;" class="fragment" data-fragment-index="0">
								<img src="images/detached-dom-tree.png"/>
							</div>
						</div>
					</section>

					<section>
						<h2>GC roots</h2>
						<div class="story">Study the mafia connections</div>
						<div>Objects and Node elements which have released all references to GC root are eligable to be GC-ed</div><br/>

						<h3>What are GC roots?</h3>
						<ul>
							<li>Global object - <b>Global</b> in NodeJS / <b>window</b> in browser</li>
							<li><b>document</b> object in the browser</li>
							<li>Other GC roots with no interest to the developer: built-in object maps, stacks of VM threads, compilation cache, etc.</li>
						</ul><br/><br/>

						<div>We have no control from code on the GC process</div>
					</section>
				</section>

				<section>
					<h2>Chrome Dev Tools</h2>
					<div class="story">Let's get equipped</div>
					<ul>
						<li class="fragment" data-fragment-index="0">Timeline - detect memory management issues</li>
						<li class="fragment" data-fragment-index="1">Profiling - explore App objects and track explicit sources for memory leaks</li>
					</ul>
				</section>

				<section data-transition="linear" data-background="#007777" data-background-transition="slide">
					<section>
						<h2>Detecting a problem in memory management</h2>
						<ol>
							<li class="fragment" data-fragment-index="0">Test App with a clean environment</li>
							<li class="fragment" data-fragment-index="1">Activate the timeline recording</li>
							<li class="fragment" data-fragment-index="2">Choose a suspected scenario and repeat it back and forth several times while recording</li>
							<li class="fragment" data-fragment-index="3">After each iteration, force GC by pressing the garbage-can button</li>
							<li class="fragment" data-fragment-index="4">Wait for few seconds and stop recording</li>
							<li class="fragment" data-fragment-index="5">analyze resulted graph</li>
						</ol>
					</section>

					<section>
						<h2>What is a clean environment?</h2>
						<div>We want to isolate any unwanted references to our code that may distract us</div><br/>
						<ul>
							<li class="fragment" data-fragment-index="0">Open browser from the command line with <b>--nocranckshaft</b> and <b>--noopt</b> flags on</li>
							<li class="fragment" data-fragment-index="1">Open browser in incognito mode to disable browser extensions that may add references: Batarang amongst them</li>
							<li class="fragment" data-fragment-index="2">Run App in a mode that disables console logs, as they are keeping references to the code they inspect</li> 
							<li class="fragment" data-fragment-index="3">Run App in production mode to simulate real environment</li>
						</ul>
					</section>

					<section>
						<h2>Timeline graph patterns</h2>
						<div class="fragment" data-fragment-index="0">Memory get fully GC-ed</div>
						<div class="fragment" data-fragment-index="0">
							<img src="images/normal-memory.png"/>
						</div>
						<div class="fragment" data-fragment-index="1">Potential memory leak</div>
						<div class="fragment" data-fragment-index="1">
							<img src="images/memory-leak-graph.png"/>
						</div>
					</section>

					<section>
						<h2>Some notes on timeline recording</h2>
						<ol>
							<li class="fragment" data-fragment-index="0">GC has it's own strategies. You may want to leave the recording on idle state for few minutes to ensure GC</li>
							<li class="fragment" data-fragment-index="1">Run App in production mode to simulate real environment</li>
						</ol>
					</section>
				</section>

				<section data-transition="linear" data-background="#8c4738" data-background-transition="slide">
					<section>
						<h2>Detecting memory leaks causes</h2>
						<ol>
							<li class="fragment" data-fragment-index="0">Test App with a clean environment</li>
							<li class="fragment" data-fragment-index="1">Choose a suspected scenraio</li>
							<li class="fragment" data-fragment-index="2">Take a heap snapshot</li>
							<li class="fragment" data-fragment-index="3">Make the steps of the scenario</li>
							<li class="fragment" data-fragment-index="4">Take another snapshot</li>
							<li class="fragment" data-fragment-index="5">Make the scenario reverse actions</li>
							<li class="fragment" data-fragment-index="6">Take a last snapshot</li>
							<li class="fragment" data-fragment-index="7">Switch to comparison mode and compare first and last snapshots</li>
							<li class="fragment" data-fragment-index="8">Filter results to show detached DOM trees</li>
							<li class="fragment" data-fragment-index="9">Analyze results</li>
						</ol>
					</section>

					<section>
						<h2>Analyzing results</h2>
						<ul>
							<li class="fragment" data-fragment-index="0">Retaining tree is a reverse pyramid of references</li>
							<li class="fragment" data-fragment-index="1">Entries with red background - Detached elements</li>
							<li class="fragment" data-fragment-index="2">Entries with yellow background further up the retaining tree - objects with a reference to GC root</li>
							<li class="fragment" data-fragment-index="3">Distance column - distance to root</li> 
						</ul><br/><br/>
						<div>
							<img src="images/rataining-tree.png" style="height: 300px;" />
						</div>
					</section>

					<section>
						<h2>Fixing and validating</h2>
						<ul>
							<li class="fragment" data-fragment-index="0">Recognize your place in code using clues from the retaining tree. Issue should be around the yellow entry</li>
							<li class="fragment" data-fragment-index="1">Review suspected code</li>
							<li class="fragment" data-fragment-index="2">Release DOM tree in code</li>
							<li class="fragment" data-fragment-index="3">Repeat detection steps to see if problem solved</li>
					</section>

					<section>
						<h2>Some notes on profiling</h2>
						<ol>
							<li class="fragment" data-fragment-index="0">Each snapshot starts with a garbage collecting. No need to force it</li>
							<li class="fragment" data-fragment-index="1">Name closure functions. They will help you get around the retaining tree<br/>
								<img src="images/named-closure-function.png" />
							</li>
							<li class="fragment" data-fragment-index="2">Run in production mode but use source maps</li>
						</ol>
					</section>
				</section>

				<section>
					<h2>Memory leaks in SPA</h2>
					<ul>
						<li class="fragment" data-fragment-index="0">Complexity of code and coponents</li>
						<li class="fragment" data-fragment-index="1">Multi develpers environment</li>
						<li class="fragment" data-fragment-index="2">Application may run days before refreshing the page</li> 
						<li class="fragment" data-fragment-index="3">Detached application sections (ng-if)</li>
					</ul>
				</section>

				<section>
					<h2>AngularJS - areas of interest</h2>
					<ul>
						<li class="fragment" data-fragment-index="0">DOM manipulations in controllers (that's a no-no)</li>
						<li class="fragment" data-fragment-index="1">Regular object growth - easy to track</li>
						<li class="fragment" data-fragment-index="2">Angular "normal" detached DOM trees (ng-if, ng-include, ng-switch, etc.)</li>
						<li class="fragment" data-fragment-index="3">Memory leaks in directives - our main interest</li>
					</ul>
				</section>

				<section data-transition="linear" data-background="#33aa22" data-background-transition="slide">
					<section>
						<h2>Memory leaks in Angular.JS directives</h2>
						<h3>What we should do when scope has to die</h3>
					</section>

					<section>
						<h2>Directives - release event listeners</h2>
						<ul>
							<li>Unbind any event listeners that are registered on DOM elements, global objects or inside closure</li>
							<li>Use scope $destroy event which is broadcasted prior to scope destruction</li>
						</ul>
						<pre>
							<code data-trim contenteditable>
function johnGottiDirective () {
    return function (scope, element, attrs) {
    	function stealMerchandise() {
			// Do some stealling
		}

    	element.on('click', stealMerchandise);

    	scope.$on('$destroy', function arrestJohnGotti() {
    		element.off('click', stealMerchandise);
    	})
    };
}
							</code>
						</pre>
					</section>

					<section>
						<h2>Directives - release DOM trees</h2>
						<ul>
							<li>Release any reference to detached DOM trees</li>
							<li>Use scope $destroy event which is broadcasted prior to scope destruction</li>
						</ul>
						<pre>
							<code data-trim contenteditable>
function alCaponeDirective () {
	var treasure = [];

    return function (scope, element, attrs) {
    	function storeRobbedMoney(robbery) {
			treasure.push(robbery)
		}

    	angular.forEach(element.children('.robbery'), function (robbery) {
    		storeRobbedMoney(robbery);
    	});

    	scope.$on('$destroy', function findAlCaponeTreasure() {
    		treasue = null;
    	})
    };
}
							</code>
						</pre>
					</section>

					<section>
						<h2>Directives - stop any running interval</h2>
						<ul>
							<li>If using <code>setInterval</code>, release on $destroy event</li>
							<li>Use of $interval service does not save you the manual destruction of the interval</li>
						</ul>
						<pre>
							<code data-trim contenteditable>
function tedBundyDirective ($interval) {

    return function (scope, element, attrs) {
    	var killingInterval = $interval(function kill(robbery) {
			// kill
		});

    	scope.$on('$destroy', function arrestTedBundy() {
    		$interval.cancel(killingInterval);
    	})
    };
}
							</code>
						</pre>
					</section>

					<section>
						<h2>Directives - elements created with jQuery</h2>
						<ul>
							<li>Should be removed with jQuery alone</li>
							<li>Removing with DOM api, will leave jQuery cache object in memory</li>
						</ul>
						<pre>
							<code data-trim contenteditable>
function leeHarveyOswaldDirective () {
	var bullet;

    return function (scope, element, attrs) {
    	bullet = angular.element('<bullet>');

    	// shoot

    	scope.$on('$destroy', function arrestLeeHarvey() {
    		bullet.remove();
    		bullet = null;
    	})
    };
}
							</code>
						</pre>
					</section>
				</section>


				<section data-transition="linear" data-background="#224488" data-background-transition="slide">
					<section>
						<h2>Surprising profiling results</h2>
						<ul>
							<li>ng-if directive</li>
							<li>ng-switch directive</li>
							<li>ng-include directive</li>
						</ul><br/><br/>
						<div class="fragment" data-fragment-index="0">All of the above are not memory leaks but may be optimized</div>
					</section>
					
				</section>

				<section>
					<section>
						<h2>Thank you!</h2>
						<ul>
							<li>Presentation slides online: <a href="http://slides.com/eshcharc/private-leaking-investigation">http://slides.com/eshcharc/private-leaking-investigation</a></li>
							<li>Memory leaking playground (crime scene): <a href="https://github.com/eshcharc/private-leaking-investigation">https://github.com/eshcharc/private-leaking-investigation</a></li>
							<li>Questions: <a href="mailto:eshcharc@gmail.com">eshcharc@gmail.com</a></li>
						</ul><br/><br/>
						
					</section>
					
				</section>




		

				<!-- <section>
					<section id="fragments">
						<h2>Fragmented Views</h2>
						<p>Hit the next arrow...</p>
						<p class="fragment">... to step through ...</p>
						<ol>
							<li class="fragment"><code>any type</code></li>
							<li class="fragment"><em>of view</em></li>
							<li class="fragment"><strong>fragments</strong></li>
						</ol>

						<aside class="notes">
							This slide has fragments which are also stepped through in the notes window.
						</aside>
					</section>
					<section>
						<h2>Fragment Styles</h2>
						<p>There's a few styles of fragments, like:</p>
						<p class="fragment grow">grow</p>
						<p class="fragment shrink">shrink</p>
						<p class="fragment roll-in">roll-in</p>
						<p class="fragment fade-out">fade-out</p>
						<p class="fragment highlight-red">highlight-red</p>
						<p class="fragment highlight-green">highlight-green</p>
						<p class="fragment highlight-blue">highlight-blue</p>
						<p class="fragment current-visible">current-visible</p>
						<p class="fragment highlight-current-blue">highlight-current-blue</p>
					</section>
				</section> -->
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
